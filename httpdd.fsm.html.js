// Generated by CoffeeScript 1.10.0
(function() {
  var addArrow, addAssignment, addDecision, addDeclaration, addFinal, addInitial, addStatusCode, addTransition, cells, declarations, gridCellHeight, gridCellWidth, gridCellsH, gridCellsV, gridMultiplier, jsonFsmUrl, parseCoords, render, stmts, transitions, vars;

  jsonFsmUrl = window.location.search.substr(1);

  jsonFsmUrl = jsonFsmUrl.length ? jsonFsmUrl : 'httpdd.fsm.json';

  $.ajaxSetup({
    cache: false
  });

  stmts = [];

  vars = {};

  declarations = {
    state: {},
    status_code: {},
    decision: {},
    block: {},
    block_entry: {}
  };

  transitions = {};

  gridMultiplier = parseInt(window.location.hash.substr(1), 10) || 20;

  gridCellWidth = 10;

  gridCellHeight = 4;

  gridCellsH = 1;

  gridCellsV = 1;

  cells = [];

  render = function() {
    var graph, paper, paperHeight, paperWidth;
    paperWidth = gridMultiplier * gridCellWidth * (gridCellsH + 1);
    paperHeight = gridMultiplier * gridCellHeight * (gridCellsV + 1);
    graph = new joint.dia.Graph();
    paper = new joint.dia.Paper({
      el: $('#paper'),
      width: paperWidth,
      height: paperHeight,
      gridSize: gridMultiplier,
      model: graph,
      async: true
    });
    V(paper.svg).defs().append(V("<pattern id=\"smallGrid\" width=\"" + gridMultiplier + "\" height=\"" + gridMultiplier + "\" patternUnits=\"userSpaceOnUse\">\n  <path d=\"M " + gridMultiplier + " 0 L 0 0 0 " + gridMultiplier + "\" fill=\"none\" stroke=\"#EEEEEE\" stroke-width=\"0.5\"/>\n</pattern>\n<pattern id=\"grid\" width=\"" + (gridMultiplier * 10) + "\" height=\"" + (gridMultiplier * 4) + "\" patternUnits=\"userSpaceOnUse\">\n  <rect width=\"" + (gridMultiplier * 10) + "\" height=\"" + (gridMultiplier * 4) + "\" fill=\"url(#smallGrid)\"/>\n  <path d=\"M " + (gridMultiplier * 10) + " 0 L 0 0 0 " + (gridMultiplier * 4) + "\" fill=\"none\" stroke=\"#EEEEEE\" stroke-width=\"1\"/>\n</pattern>"));
    V(paper.svg).prepend(V("<rect width=\"100%\" height=\"100%\" fill=\"url(#grid)\" />"));
    (function() {
      var i, j, l, ref, ref1, results;
      for (i = j = 1, ref = gridCellsH; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {
        cells.push(new joint.shapes.basic.Text({
          position: {
            x: gridMultiplier * gridCellWidth * i,
            y: 0
          },
          size: {
            width: 'auto',
            height: 'auto'
          },
          attrs: {
            text: {
              text: String.fromCharCode("A".charCodeAt(0) + i - 1),
              'font-size': gridMultiplier * .5
            }
          }
        }));
        cells.push(new joint.shapes.basic.Text({
          position: {
            x: gridMultiplier * gridCellWidth * i,
            y: paperHeight - gridMultiplier
          },
          size: {
            width: 'auto',
            height: 'auto'
          },
          attrs: {
            text: {
              text: String.fromCharCode("A".charCodeAt(0) + i - 1),
              'font-size': gridMultiplier * .5
            }
          }
        }));
      }
      results = [];
      for (i = l = 1, ref1 = gridCellsV; 1 <= ref1 ? l <= ref1 : l >= ref1; i = 1 <= ref1 ? ++l : --l) {
        cells.push(new joint.shapes.basic.Text({
          position: {
            x: 0,
            y: gridMultiplier * gridCellHeight * i
          },
          size: {
            width: 'auto',
            height: 'auto'
          },
          attrs: {
            text: {
              text: '' + i,
              'font-size': gridMultiplier * .5
            }
          }
        }));
        results.push(cells.push(new joint.shapes.basic.Text({
          position: {
            x: paperWidth - gridMultiplier,
            y: gridMultiplier * gridCellHeight * i
          },
          size: {
            width: 'auto',
            height: 'auto'
          },
          attrs: {
            text: {
              text: '' + i,
              'font-size': gridMultiplier * .5
            }
          }
        })));
      }
      return results;
    })();
    return graph.addCells(cells);
  };

  joint.shapes.httpdd = {};

  joint.shapes.fsa.StartState = joint.dia.Element.extend({
    markup: '<g class="rotatable"><g class="scalable"><circle/></g></g>',
    defaults: joint.util.deepSupplement({
      type: 'fsa.StartState',
      size: {
        width: gridMultiplier * 2,
        height: gridMultiplier * 2
      },
      attrs: {
        circle: {
          transform: 'translate(0,0)',
          r: gridMultiplier,
          fill: 'black'
        }
      }
    }, joint.dia.Element.prototype.defaults)
  });

  joint.shapes.fsa.EndState = joint.dia.Element.extend({
    markup: '<g class="rotatable"><g class="scalable"><circle class="outer"/><circle class="inner"/></g></g>',
    defaults: joint.util.deepSupplement({
      type: 'fsa.EndState',
      size: {
        width: gridMultiplier * 2,
        height: gridMultiplier * 2
      },
      attrs: {
        '.outer': {
          transform: 'translate(0,0)',
          r: gridMultiplier,
          fill: 'white',
          stroke: 'black'
        },
        '.inner': {
          transform: 'translate(0,0)',
          r: gridMultiplier / 2,
          fill: 'black'
        }
      }
    }, joint.dia.Element.prototype.defaults)
  });

  joint.shapes.httpdd.Decision = joint.dia.Element.extend({
    markup: '<g class="rotatable"><g class="scalable"><path/></g><text class="decision"/><text class="coord"/></g>',
    defaults: joint.util.deepSupplement({
      type: 'httpdd.Decision',
      size: {
        width: gridMultiplier * 2,
        height: gridMultiplier * 2
      },
      attrs: {
        '.': {
          fill: '#FFFFFF',
          stroke: 'none'
        },
        path: {
          d: 'M 30 0 L 60 30 30 60 0 30 z',
          transform: 'translate(' + (-gridMultiplier * 1.5) + ', ' + (-gridMultiplier * 1.5) + ')',
          'stroke-width': 0,
          fill: '#EEEEEE'
        },
        '.decision': {
          'font-size': gridMultiplier * .5,
          text: '',
          'text-anchor': 'middle',
          'ref-x': .5,
          'ref-y': .1,
          'ref-dy': 20,
          ref: 'path',
          'y-alignment': 'middle',
          fill: 'black',
          'font-family': 'Arial, helvetica, sans-serif'
        },
        '.coord': {
          'font-size': gridMultiplier * .5,
          text: '',
          'text-anchor': 'middle',
          'ref-x': .5,
          'ref-y': .5,
          'ref-dy': 20,
          ref: 'path',
          'y-alignment': 'middle',
          fill: 'black',
          'font-family': 'Arial, helvetica, sans-serif'
        }
      }
    }, joint.dia.Element.prototype.defaults)
  });

  joint.shapes.httpdd.StatusCode = joint.shapes.basic.Rect.extend({
    defaults: joint.util.deepSupplement({
      type: 'httpdd.StatusCode',
      size: {
        width: gridMultiplier * 10,
        height: gridMultiplier * 2
      },
      attrs: {
        rect: {
          transform: 'translate(' + (-gridMultiplier * 2.5) + ', ' + (-gridMultiplier * 1.5) + ')',
          'stroke-width': 0,
          fill: '#EEEEEE'
        },
        text: {
          'font-size': gridMultiplier * .5
        }
      }
    }, joint.shapes.basic.Rect.prototype.defaults)
  });

  addInitial = function(state) {
    var cell;
    cell = new joint.shapes.fsa.StartState({
      position: {
        x: state.center.x,
        y: state.center.y
      }
    });
    cells.push(cell);
    return cell;
  };

  addFinal = function(state) {
    var cell;
    cell = new joint.shapes.fsa.EndState({
      position: {
        x: state.center.x,
        y: state.center.y
      }
    });
    cells.push(cell);
    return cell;
  };

  addDecision = function(state) {
    var cell;
    cell = new joint.shapes.httpdd.Decision({
      position: {
        x: state.center.x,
        y: state.center.y
      },
      attrs: {
        '.decision': {
          text: state.name.replace(/_/g, ' ')
        },
        '.coord': {
          text: "" + state.center.col + state.center.lin
        }
      }
    });
    cells.push(cell);
    return cell;
  };

  addStatusCode = function(state) {
    var cell;
    cell = new joint.shapes.httpdd.StatusCode({
      position: {
        x: state.center.x,
        y: state.center.y
      },
      attrs: {
        text: {
          text: state.name.replace(/_/g, ' ')
        }
      }
    });
    cells.push(cell);
    return cell;
  };

  addArrow = function(transition) {
    var cell, color, message;
    switch (transition.message) {
      case 'true':
        message = 'T';
        color = '#00FF00';
        break;
      case 'false':
        message = 'F';
        color = '#FF0000';
        break;
      case 'anything':
        message = '';
        color = '#0000FF';
    }
    cell = new joint.shapes.fsa.Arrow({
      smooth: false,
      source: {
        id: transition.state.id
      },
      target: {
        id: transition.next_state.id
      },
      attrs: {
        '.connection': {
          stroke: color
        },
        '.marker-source': {
          stroke: color,
          fill: color
        },
        '.marker-target': {
          stroke: color,
          fill: color
        }
      },
      vertices: transition.coords
    });
    cells.push(cell);
    return cell;
  };

  parseCoords = function(arg) {
    var col, lin, x, y;
    x = arg.x, y = arg.y;
    col = x;
    lin = y;
    x = x.toUpperCase();
    if (x.length === 1) {
      x += x;
    }
    x = x.charCodeAt(0) + (x.charCodeAt(1) - x.charCodeAt(0)) / 2;
    x = x - "A".charCodeAt(0) + 1;
    if (x > gridCellsH) {
      gridCellsH = x;
    }
    x = gridMultiplier * gridCellWidth * x;
    y = parseInt(y, 10);
    if (y > gridCellsV) {
      gridCellsV = y;
    }
    y = gridMultiplier * gridCellHeight * y;
    return {
      x: x,
      y: y,
      col: col,
      lin: lin
    };
  };

  addAssignment = function(name, value) {
    return vars[name] = value;
  };

  addDeclaration = function(type, names) {
    var coord, j, l, len, len1, ref, results, state;
    if (declarations[type] == null) {
      declarations[type] = {};
    }
    results = [];
    for (j = 0, len = names.length; j < len; j++) {
      state = names[j];
      if (typeof state === 'string') {
        state = {
          name: state
        };
      }
      ref = ['center', 'top_left', 'bottom_right'];
      for (l = 0, len1 = ref.length; l < len1; l++) {
        coord = ref[l];
        if (state[coord] == null) {
          continue;
        }
        state[coord] = parseCoords(state[coord]);
      }
      if ((state.top_left != null) && (state.bottom_right != null) && state.center === void 0) {
        state.center = {
          x: (state.bottom_right.x - state.top_left.x) / 2,
          y: (state.bottom_right.y - state.top_left.y) / 2
        };
      }
      results.push(declarations[type][state.name] = state);
    }
    return results;
  };

  addTransition = function(state, next_state, message, coords) {
    var xy;
    if (coords == null) {
      coords = [];
    }
    coords = (function() {
      var j, len, results;
      results = [];
      for (j = 0, len = coords.length; j < len; j++) {
        xy = coords[j];
        results.push(parseCoords(xy));
      }
      return results;
    })();
    return transitions[state + ":" + message + ":" + next_state] = {
      state: state,
      next_state: next_state,
      message: message,
      coords: coords
    };
  };

  $.getJSON(jsonFsmUrl, function(httpdd) {
    var j, k, k2, l, len, len1, len2, m, message, ref, ref1, ref2, state, stmt, v, v2;
    stmts = httpdd.statements;
    for (j = 0, len = stmts.length; j < len; j++) {
      stmt = stmts[j];
      switch (stmt.__type) {
        case 'assignment':
          addAssignment(stmt.name, stmt.value);
          break;
        case 'declaration':
          addDeclaration(stmt.value, stmt.names);
          break;
        case 'transition':
          ref = stmt.states;
          for (l = 0, len1 = ref.length; l < len1; l++) {
            state = ref[l];
            ref1 = stmt.messages;
            for (m = 0, len2 = ref1.length; m < len2; m++) {
              message = ref1[m];
              addTransition(state, stmt.next_state, message, stmt.coords);
            }
          }
      }
    }
    declarations.decision[vars.Initial] = declarations.state[vars.Initial] = addInitial(declarations.state[vars.Initial]);
    declarations.decision[vars.Final] = declarations.state[vars.Final] = addFinal(declarations.state[vars.Final]);
    ref2 = declarations.decision;
    for (k in ref2) {
      v = ref2[k];
      if (k === vars.Initial || k === vars.Final) {
        continue;
      }
      declarations.decision[k] = declarations.state[k] = addDecision(v);
    }
    for (k in transitions) {
      v = transitions[k];
      if (declarations.block_entry[v.next_state] == null) {
        continue;
      }
      for (k2 in transitions) {
        v2 = transitions[k2];
        if (v2.state !== v.next_state) {
          continue;
        }
        v.next_state = v2.next_state;
        break;
      }
    }
    for (k in transitions) {
      v = transitions[k];
      if (declarations.block_entry[v.state] != null) {
        continue;
      }
      if (declarations.status_code[v.state] != null) {
        if (!v.coords.length) {
          continue;
        }
        v.state = {
          name: declarations.state[v.state].name,
          center: v.coords[0]
        };
        v.state = addStatusCode(v.state);
        v.coords = v.coords.slice(1, v.coords.length);
      } else {
        v.state = declarations.state[v.state];
      }
      if (declarations.status_code[v.next_state] != null) {
        v.next_state = {
          name: declarations.state[v.next_state].name,
          center: v.coords[v.coords.length - 1]
        };
        v.next_state = addStatusCode(v.next_state);
        v.coords = v.coords.slice(0, v.coords.length - 1);
      } else {
        v.next_state = declarations.state[v.next_state];
      }
      transitions[k] = addArrow(v);
    }
    return render();
  });

}).call(this);
